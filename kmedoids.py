# -*- coding: utf-8 -*-
"""KMedoids.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zLaODDcYfx9uigQplImHOzKI2KAz2jqu
"""

import pandas as pd
import numpy as np
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
import matplotlib.pyplot as plt

# Load the dataset
data = pd.read_csv('/content/NIFTY50_data.csv')

# Handle missing values if any
data.fillna(method='ffill', inplace=True)
data = data.drop(columns=['Date']).T
# print(data)
# Normalize the data
scaler = StandardScaler()
data_scaled = scaler.fit_transform(data)
print(data_scaled.shape)

# K-medoids algorithm implementation
def kmedoids(data, k, max_iter=100):
    m, n = data.shape

    # Initialize medoids randomly
    medoids = np.random.choice(m, k, replace=False)
    print(medoids)

    # Initialize clusters
    clusters = np.zeros(m)
    print(clusters)

    # Function to compute the distance matrix
    def compute_distance_matrix(data):
        distance_matrix = np.zeros((m, m))
        for i in range(m):
            for j in range(m):
                distance_matrix[i, j] = np.linalg.norm(data[i] - data[j])
        return distance_matrix

    # Compute the initial distance matrix
    distance_matrix = compute_distance_matrix(data)
    print(distance_matrix)

    for _ in range(max_iter):
        # Assign each point to the closest medoid
        for i in range(m):
            distances_to_medoids = [distance_matrix[i, medoid] for medoid in medoids]
            clusters[i] = np.argmin(distances_to_medoids)

        # Update medoids
        new_medoids = np.copy(medoids)
        for i in range(k):
            cluster_points = np.where(clusters == i)[0]
            if len(cluster_points) == 0:
                continue
            # Calculate the cost for each point in the cluster to become the new medoid
            min_cost = float('inf')
            for point in cluster_points:
                cost = np.sum(distance_matrix[point][cluster_points])
                if cost < min_cost:
                    min_cost = cost
                    new_medoids[i] = point

        # Check for convergence
        if np.array_equal(medoids, new_medoids):
            break
        medoids = new_medoids

    return medoids, clusters

# Number of clusters
n_clusters = 5

# Run K-medoids
medoids, clusters = kmedoids(data_scaled, n_clusters)

# Assign cluster labels to the original data
data['Cluster'] = clusters

# Analyze the cluster assignments
print(data.groupby('Cluster').mean())

# Reduce dimensions for visualization
pca = PCA(n_components=2)
data_pca = pca.fit_transform(data_scaled)

# Plot the clustered data
plt.figure(figsize=(10, 6))
for cluster in range(n_clusters):
    cluster_points = data_pca[clusters == cluster]
    plt.scatter(cluster_points[:, 0], cluster_points[:, 1], label=f'Cluster {cluster}')

# Highlight medoids
medoid_points = data_pca[medoids]
# plt.scatter(medoid_points[:, 0], medoid_points[:, 1], color='red', marker='X', s=200, label='Medoids')

plt.title('K-Medoids Clustering')
plt.xlabel('PCA Component 1')
plt.ylabel('PCA Component 2')
plt.legend()
plt.show()